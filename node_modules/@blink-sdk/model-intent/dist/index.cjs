//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let ai = require("ai");
ai = __toESM(ai);
let zod = require("zod");
zod = __toESM(zod);

//#region src/index.ts
/**
* Wraps every tool in the tool set with a "model_intent" property.
* This is useful for understanding the intent of tool calls.
*
* The "model_intent" can be sent elsewhere if relevant - for example, in a Slack status.
*
* @param tools
* @param onModelIntent
*/
function withModelIntent(tools, options) {
	const wrapped = {};
	const inputDeltas = {};
	const debounceMs = options?.debounce ?? 50;
	let pendingByToolCallId = {};
	let lastSentByToolCallId = {};
	let debounceTimer = null;
	const flushModelIntents = () => {
		if (!options?.onModelIntents) return;
		const values = Object.values(pendingByToolCallId);
		if (values.length === 0) return;
		const changed = values.filter((intent) => lastSentByToolCallId[intent.toolCallId] !== intent.modelIntent);
		pendingByToolCallId = {};
		if (changed.length === 0) {
			debounceTimer = null;
			return;
		}
		options.onModelIntents(changed);
		for (const intent of changed) lastSentByToolCallId[intent.toolCallId] = intent.modelIntent;
		debounceTimer = null;
	};
	const queueModelIntent = (intent) => {
		if (!options?.onModelIntents) return;
		pendingByToolCallId[intent.toolCallId] = intent;
		if (debounceTimer) clearTimeout(debounceTimer);
		debounceTimer = setTimeout(flushModelIntents, debounceMs);
	};
	for (const [key, value] of Object.entries(tools)) wrapped[key] = (0, ai.tool)({
		...value,
		inputSchema: zod.z.object({
			model_intent: zod.z.string().describe("A short present-participle description of the tool call's purpose."),
			properties: value.inputSchema
		}),
		execute: value.execute ? async (input, options$1) => {
			return value.execute(input.properties, options$1);
		} : void 0,
		onInputDelta: async ({ inputTextDelta, toolCallId, abortSignal }) => {
			if (abortSignal?.aborted) {
				delete inputDeltas[toolCallId];
				delete pendingByToolCallId[toolCallId];
				delete lastSentByToolCallId[toolCallId];
				return;
			}
			if (abortSignal) abortSignal.addEventListener("abort", () => {
				delete inputDeltas[toolCallId];
				delete pendingByToolCallId[toolCallId];
				delete lastSentByToolCallId[toolCallId];
				if (Object.keys(pendingByToolCallId).length === 0 && debounceTimer) {
					clearTimeout(debounceTimer);
					debounceTimer = null;
				}
			}, { once: true });
			if (!inputDeltas[toolCallId]) inputDeltas[toolCallId] = "";
			inputDeltas[toolCallId] += inputTextDelta;
			const result = await (0, ai.parsePartialJson)(inputDeltas[toolCallId]);
			if (result.value && typeof result.value === "object" && "model_intent" in result.value) queueModelIntent({
				toolName: key,
				toolCallId,
				modelIntent: result.value["model_intent"]
			});
		},
		onInputAvailable: ({ input, toolCallId, abortSignal }) => {
			if (abortSignal?.aborted) {
				delete inputDeltas[toolCallId];
				delete pendingByToolCallId[toolCallId];
				delete lastSentByToolCallId[toolCallId];
				return;
			}
			if (abortSignal) abortSignal.addEventListener("abort", () => {
				delete inputDeltas[toolCallId];
				delete pendingByToolCallId[toolCallId];
				delete lastSentByToolCallId[toolCallId];
				if (Object.keys(pendingByToolCallId).length === 0 && debounceTimer) {
					clearTimeout(debounceTimer);
					debounceTimer = null;
				}
			}, { once: true });
			queueModelIntent({
				toolName: key,
				toolCallId,
				modelIntent: input.model_intent
			});
		}
	});
	return wrapped;
}

//#endregion
module.exports = withModelIntent;