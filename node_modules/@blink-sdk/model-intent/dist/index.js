import { parsePartialJson, tool } from "ai";
import { z } from "zod";

//#region src/index.ts
/**
* Wraps every tool in the tool set with a "model_intent" property.
* This is useful for understanding the intent of tool calls.
*
* The "model_intent" can be sent elsewhere if relevant - for example, in a Slack status.
*
* @param tools
* @param onModelIntent
*/
function withModelIntent(tools, options) {
	const wrapped = {};
	const inputDeltas = {};
	const debounceMs = options?.debounce ?? 50;
	let pendingByToolCallId = {};
	let lastSentByToolCallId = {};
	let debounceTimer = null;
	const flushModelIntents = () => {
		if (!options?.onModelIntents) return;
		const values = Object.values(pendingByToolCallId);
		if (values.length === 0) return;
		const changed = values.filter((intent) => lastSentByToolCallId[intent.toolCallId] !== intent.modelIntent);
		pendingByToolCallId = {};
		if (changed.length === 0) {
			debounceTimer = null;
			return;
		}
		options.onModelIntents(changed);
		for (const intent of changed) lastSentByToolCallId[intent.toolCallId] = intent.modelIntent;
		debounceTimer = null;
	};
	const queueModelIntent = (intent) => {
		if (!options?.onModelIntents) return;
		pendingByToolCallId[intent.toolCallId] = intent;
		if (debounceTimer) clearTimeout(debounceTimer);
		debounceTimer = setTimeout(flushModelIntents, debounceMs);
	};
	for (const [key, value] of Object.entries(tools)) wrapped[key] = tool({
		...value,
		inputSchema: z.object({
			model_intent: z.string().describe("A short present-participle description of the tool call's purpose."),
			properties: value.inputSchema
		}),
		execute: value.execute ? async (input, options$1) => {
			return value.execute(input.properties, options$1);
		} : void 0,
		onInputDelta: async ({ inputTextDelta, toolCallId, abortSignal }) => {
			if (abortSignal?.aborted) {
				delete inputDeltas[toolCallId];
				delete pendingByToolCallId[toolCallId];
				delete lastSentByToolCallId[toolCallId];
				return;
			}
			if (abortSignal) abortSignal.addEventListener("abort", () => {
				delete inputDeltas[toolCallId];
				delete pendingByToolCallId[toolCallId];
				delete lastSentByToolCallId[toolCallId];
				if (Object.keys(pendingByToolCallId).length === 0 && debounceTimer) {
					clearTimeout(debounceTimer);
					debounceTimer = null;
				}
			}, { once: true });
			if (!inputDeltas[toolCallId]) inputDeltas[toolCallId] = "";
			inputDeltas[toolCallId] += inputTextDelta;
			const result = await parsePartialJson(inputDeltas[toolCallId]);
			if (result.value && typeof result.value === "object" && "model_intent" in result.value) queueModelIntent({
				toolName: key,
				toolCallId,
				modelIntent: result.value["model_intent"]
			});
		},
		onInputAvailable: ({ input, toolCallId, abortSignal }) => {
			if (abortSignal?.aborted) {
				delete inputDeltas[toolCallId];
				delete pendingByToolCallId[toolCallId];
				delete lastSentByToolCallId[toolCallId];
				return;
			}
			if (abortSignal) abortSignal.addEventListener("abort", () => {
				delete inputDeltas[toolCallId];
				delete pendingByToolCallId[toolCallId];
				delete lastSentByToolCallId[toolCallId];
				if (Object.keys(pendingByToolCallId).length === 0 && debounceTimer) {
					clearTimeout(debounceTimer);
					debounceTimer = null;
				}
			}, { once: true });
			queueModelIntent({
				toolName: key,
				toolCallId,
				modelIntent: input.model_intent
			});
		}
	});
	return wrapped;
}

//#endregion
export { withModelIntent as default };