import { SlackAPIClient, SlackApp } from "slack-edge";
import blink from "blink";

//#region src/helpers.ts
/**
* Helps LLMs format messages for Slack.
*
* @param text - The text to format.
* @returns The formatted text.
*/
function formatSlackMessage(text) {
	const maxLength = 3e3;
	if (text.length > maxLength) text = text.slice(0, maxLength);
	text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "<$2|$1>");
	text = text.replace(/\*\*([^*]+)\*\*/g, "*$1*");
	text = text.replace(/(?<!<)@(U|W)[A-Z0-9]{8,}(?!>)/g, (match) => `<${match}>`);
	text = text.replace(/(^|[^A-Z0-9<@])((?:U|W)[A-Z0-9]{8,})(?![A-Z0-9>])/g, (m, prefix, id) => `${prefix}<@${id}>`);
	text = text.replace(/<@([a-z0-9._-]+)>/gi, (m, u) => /^[UW][A-Z0-9]{8,}$/.test(u) ? m : `@${u}`);
	return text;
}
const getTokenStorageKey = (teamId) => `slackbot_token_${teamId}`;
const ensureSecrets = () => {
	const createError = (name) => {
		return /* @__PURE__ */ new Error(`${name} is not set`);
	};
	if (!process.env.SLACK_CLIENT_ID) throw createError("SLACK_CLIENT_ID");
	if (!process.env.SLACK_CLIENT_SECRET) throw createError("SLACK_CLIENT_SECRET");
	if (!process.env.SLACK_SIGNING_SECRET) throw createError("SLACK_SIGNING_SECRET");
	return {
		clientId: process.env.SLACK_CLIENT_ID,
		clientSecret: process.env.SLACK_CLIENT_SECRET,
		signingSecret: process.env.SLACK_SIGNING_SECRET
	};
};
/**
* Gets a refreshed token for a given team from Blink storage.
*
* @param teamId - The team ID.
* @returns The token data.
*/
async function getRefreshedToken(teamId) {
	const token = await getToken(teamId);
	if (!token) return void 0;
	if (token.expiresAt > Date.now()) return token;
	const client = new SlackAPIClient();
	const { clientId, clientSecret } = ensureSecrets();
	const response = await client.oauth.v2.access({
		client_id: clientId,
		client_secret: clientSecret,
		refresh_token: token.refreshToken,
		grant_type: "refresh_token"
	});
	if (!response.ok) throw new Error(`Failed to refresh token for team ${teamId}: ${response.error}`);
	return saveToken(response);
}
async function getToken(teamId) {
	const token = await blink.storage.get(getTokenStorageKey(teamId));
	if (!token) return void 0;
	return JSON.parse(token);
}
/**
* Saves a token for a given team to Blink storage.
*
* @param teamId - The team ID.
* @param tokenData - The token data.
*/
async function saveToken(oauthResponse) {
	const ensureProperty = (name) => {
		if (!oauthResponse[name]) throw new Error(`${name} was not returned from the Slack OAuth exchange. This is a bug in the Slack SDK. Please report this to https://github.com/coder/blink/issues.`);
		return oauthResponse[name];
	};
	const teamId = ensureProperty("team").id;
	if (!teamId) throw new Error("team.id was not returned from the Slack OAuth exchange. This is a bug in the Slack SDK. Please report this to https://github.com/coder/blink/issues.");
	const tokenData = {
		accessToken: ensureProperty("access_token"),
		refreshToken: ensureProperty("refresh_token"),
		expiresAt: Date.now() + ensureProperty("expires_in") * 1e3,
		scopes: ensureProperty("scope").split(","),
		botId: ensureProperty("app_id"),
		botUserId: ensureProperty("bot_user_id")
	};
	await blink.storage.set(getTokenStorageKey(teamId), JSON.stringify(tokenData));
	return tokenData;
}

//#endregion
//#region src/webhook.ts
/**
* Checks if a request is an OAuth request from Slack.
*
* @param request - The incoming request.
* @returns True if the request is an OAuth request, false otherwise.
*/
const isOAuthRequest = (request) => {
	const url = new URL(request.url);
	return Boolean(url.searchParams.get("code"));
};
/**
* Handles an OAuth request from Slack.
*
* @param request - The incoming request.
* @returns A response to Slack.
*/
const handleOAuthRequest = async (request, options) => {
	const url = new URL(request.url);
	const code = url.searchParams.get("code");
	if (!code) return new Response("No authorization code provided", { status: 400 });
	const client = new SlackAPIClient();
	try {
		const secrets = ensureSecrets();
		const response = await client.oauth.v2.access({
			client_id: secrets.clientId,
			client_secret: secrets.clientSecret,
			code
		});
		if (!options?.disableLogging) console.log(`Slack bot authorized for team: ${response.team?.name} (${response.team?.id})`);
		await saveToken(response);
	} catch (error) {
		const message = error instanceof Error ? error.message : "Unknown error";
		return new Response(message, { status: 400 });
	}
	return new Response("The Slack bot has been authorized. It can now be installed in your workspace.", { status: 200 });
};
/**
* Checks if a request is a webhook from Slack.
*
* @param request - The incoming request.
* @returns True if the request is a webhook, false otherwise.
*/
const isWebhook = (request) => {
	return request.headers.get("x-slack-signature") !== null;
};
/**
* handleWebhook handles a Slack webhook request.
*
* @param request - The incoming request.
* @param options - The options for the Slack app.
* @returns A response to Slack.
*/
const handleWebhook = async (request, options) => {
	const app = createSlackApp(options);
	app.event("message", createMessageEventHandler());
	if (!options?.logUnhandledEvents) {
		const silentHandler = async () => {};
		allEventTypes.forEach((event) => {
			app.event(event, silentHandler);
		});
	}
	return app.run(request);
};
/**
* createApp creates a Slack app that is authorized with the
* Slack team bot token. It has no built-in handlers.
*
* Use this to entirely customize the behavior.
*
* @param options - The options for the Slack app.
* @returns The Slack app.
*/
const createSlackApp = (options) => {
	const secrets = ensureSecrets();
	const app = new SlackApp({
		env: { SLACK_SIGNING_SECRET: secrets.signingSecret },
		authorize: async ({ context }) => {
			if (!context.teamId) throw new Error("No team ID provided as part of the Slack webhook.");
			const bot = await getRefreshedToken(context.teamId);
			if (!bot) {
				if (!options?.disableWarnOnMissingToken) console.warn(`Missing bot token for team "${context.teamId}". Install the app from https://api.slack.com/apps in the "Manage Distribution" section.`);
				throw new Error(`Missing bot token for team ${context.teamId}`);
			}
			return {
				botId: bot.botId,
				botUserId: bot.botUserId,
				botToken: bot.accessToken,
				botScopes: bot.scopes
			};
		}
	}).afterAuthorize(async (req) => {
		if (process.env.SLACK_API_BASE_URL) req.context.client = new SlackAPIClient(req.context.botToken, { baseUrl: process.env.SLACK_API_BASE_URL });
	});
	return app;
};
const createMessageEventHandler = (options) => {
	return async (event) => {
		const { payload, context } = event;
		if (payload.subtype !== void 0) return;
		const mentioned = payload.text.includes(`<@${context.botUserId}>`);
		if (!options?.respondToAll && !mentioned) return;
		const parts = [
			"slack",
			payload.channel,
			"thread"
		];
		if (payload.thread_ts) parts.push(payload.thread_ts);
		else if (payload.ts) parts.push(payload.ts);
		const chat = await blink.chat.upsert(parts.join("-"));
		let message;
		if (options?.createMessage) message = await options.createMessage(event);
		else {
			const userinfo = await context.client.users.info({ user: payload.user }).then((user) => {
				return {
					real_name: user.user?.profile?.real_name ?? "N/A",
					display_name: user.user?.profile?.display_name ?? "N/A"
				};
			}).catch(() => ({
				real_name: "N/A",
				display_name: "N/A"
			}));
			let createdAt = /* @__PURE__ */ new Date();
			try {
				createdAt = /* @__PURE__ */ new Date(parseFloat(payload.ts) * 1e3);
			} catch (err) {}
			message = {
				role: "user",
				parts: [{
					type: "text",
					text: `From Slack User: <@${payload.user}>
Message Timestamp Raw: ${payload.ts} (use for reactions)
Message Timestamp Formatted: ${createdAt.toLocaleString()}
User Real Name: ${userinfo.real_name}
User Display Name: ${userinfo.display_name}

The user is chatting in Slack. You *must* respond with a "slackbot_send_message" tool.`
				}, {
					type: "text",
					text: payload.text
				}]
			};
		}
		const metadata = {
			ts: payload.ts,
			channel: payload.channel,
			teamId: context.teamId
		};
		await blink.chat.message(chat.id, {
			...message,
			metadata: {
				...message.metadata ?? {},
				...metadata
			}
		}, { behavior: options?.behavior });
		await context.client.assistant.threads.setStatus({
			channel_id: payload.channel,
			thread_ts: payload.thread_ts || payload.ts,
			status: "is typing..."
		});
	};
};
const allEventTypes = [
	"app_requested",
	"app_installed",
	"app_uninstalled_team",
	"app_deleted",
	"app_home_opened",
	"app_mention",
	"app_uninstalled",
	"assistant_thread_started",
	"assistant_thread_context_changed",
	"channel_archive",
	"channel_created",
	"channel_deleted",
	"channel_history_changed",
	"channel_id_changed",
	"channel_left",
	"channel_rename",
	"channel_shared",
	"channel_unarchive",
	"channel_unshared",
	"dnd_updated",
	"dnd_updated_user",
	"email_domain_changed",
	"emoji_changed",
	"file_change",
	"file_created",
	"file_deleted",
	"file_public",
	"file_shared",
	"file_unshared",
	"function_executed",
	"grid_migration_finished",
	"grid_migration_started",
	"group_archive",
	"group_close",
	"group_deleted",
	"group_history_changed",
	"group_left",
	"group_open",
	"group_rename",
	"group_unarchive",
	"im_close",
	"im_created",
	"im_history_changed",
	"im_open",
	"invite_requested",
	"link_shared",
	"member_joined_channel",
	"member_left_channel",
	"message",
	"message_metadata_deleted",
	"message_metadata_posted",
	"message_metadata_updated",
	"pin_added",
	"pin_removed",
	"reaction_added",
	"reaction_removed",
	"shared_channel_invite_received",
	"shared_channel_invite_accepted",
	"shared_channel_invite_approved",
	"shared_channel_invite_declined",
	"shared_channel_invite_requested",
	"star_added",
	"star_removed",
	"subteam_created",
	"subteam_members_changed",
	"subteam_self_added",
	"subteam_self_removed",
	"subteam_updated",
	"team_access_granted",
	"team_access_revoked",
	"team_domain_change",
	"team_join",
	"team_rename",
	"tokens_revoked",
	"user_change",
	"user_huddle_changed",
	"user_profile_changed",
	"user_status_changed",
	"workflow_deleted",
	"workflow_published",
	"workflow_unpublished",
	"workflow_step_deleted",
	"workflow_step_execute"
];

//#endregion
export { createMessageEventHandler, createSlackApp, formatSlackMessage, getRefreshedToken, handleOAuthRequest, handleWebhook, isOAuthRequest, isWebhook };