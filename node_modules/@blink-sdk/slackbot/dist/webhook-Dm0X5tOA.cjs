//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let slack_edge = require("slack-edge");
slack_edge = __toESM(slack_edge);
let blink = require("blink");
blink = __toESM(blink);

//#region src/helpers.ts
/**
* Helps LLMs format messages for Slack.
*
* @param text - The text to format.
* @returns The formatted text.
*/
function formatSlackMessage(text) {
	const maxLength = 3e3;
	if (text.length > maxLength) text = text.slice(0, maxLength);
	text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "<$2|$1>");
	text = text.replace(/\*\*([^*]+)\*\*/g, "*$1*");
	text = text.replace(/(?<!<)@(U|W)[A-Z0-9]{8,}(?!>)/g, (match) => `<${match}>`);
	text = text.replace(/(^|[^A-Z0-9<@])((?:U|W)[A-Z0-9]{8,})(?![A-Z0-9>])/g, (m, prefix, id) => `${prefix}<@${id}>`);
	text = text.replace(/<@([a-z0-9._-]+)>/gi, (m, u) => /^[UW][A-Z0-9]{8,}$/.test(u) ? m : `@${u}`);
	return text;
}
const getTokenStorageKey = (teamId) => `slackbot_token_${teamId}`;
const ensureSecrets = () => {
	const createError = (name) => {
		return /* @__PURE__ */ new Error(`${name} is not set`);
	};
	if (!process.env.SLACK_CLIENT_ID) throw createError("SLACK_CLIENT_ID");
	if (!process.env.SLACK_CLIENT_SECRET) throw createError("SLACK_CLIENT_SECRET");
	if (!process.env.SLACK_SIGNING_SECRET) throw createError("SLACK_SIGNING_SECRET");
	return {
		clientId: process.env.SLACK_CLIENT_ID,
		clientSecret: process.env.SLACK_CLIENT_SECRET,
		signingSecret: process.env.SLACK_SIGNING_SECRET
	};
};
/**
* Gets a refreshed token for a given team from Blink storage.
*
* @param teamId - The team ID.
* @returns The token data.
*/
async function getRefreshedToken(teamId) {
	const token = await getToken(teamId);
	if (!token) return void 0;
	if (token.expiresAt > Date.now()) return token;
	const client = new slack_edge.SlackAPIClient();
	const { clientId, clientSecret } = ensureSecrets();
	const response = await client.oauth.v2.access({
		client_id: clientId,
		client_secret: clientSecret,
		refresh_token: token.refreshToken,
		grant_type: "refresh_token"
	});
	if (!response.ok) throw new Error(`Failed to refresh token for team ${teamId}: ${response.error}`);
	return saveToken(response);
}
async function getToken(teamId) {
	const token = await blink.default.storage.get(getTokenStorageKey(teamId));
	if (!token) return void 0;
	return JSON.parse(token);
}
/**
* Saves a token for a given team to Blink storage.
*
* @param teamId - The team ID.
* @param tokenData - The token data.
*/
async function saveToken(oauthResponse) {
	const ensureProperty = (name) => {
		if (!oauthResponse[name]) throw new Error(`${name} was not returned from the Slack OAuth exchange. This is a bug in the Slack SDK. Please report this to https://github.com/coder/blink/issues.`);
		return oauthResponse[name];
	};
	const teamId = ensureProperty("team").id;
	if (!teamId) throw new Error("team.id was not returned from the Slack OAuth exchange. This is a bug in the Slack SDK. Please report this to https://github.com/coder/blink/issues.");
	const tokenData = {
		accessToken: ensureProperty("access_token"),
		refreshToken: ensureProperty("refresh_token"),
		expiresAt: Date.now() + ensureProperty("expires_in") * 1e3,
		scopes: ensureProperty("scope").split(","),
		botId: ensureProperty("app_id"),
		botUserId: ensureProperty("bot_user_id")
	};
	await blink.default.storage.set(getTokenStorageKey(teamId), JSON.stringify(tokenData));
	return tokenData;
}

//#endregion
//#region src/webhook.ts
/**
* Checks if a request is an OAuth request from Slack.
*
* @param request - The incoming request.
* @returns True if the request is an OAuth request, false otherwise.
*/
const isOAuthRequest = (request) => {
	const url = new URL(request.url);
	return Boolean(url.searchParams.get("code"));
};
/**
* Handles an OAuth request from Slack.
*
* @param request - The incoming request.
* @returns A response to Slack.
*/
const handleOAuthRequest = async (request, options) => {
	const url = new URL(request.url);
	const code = url.searchParams.get("code");
	if (!code) return new Response("No authorization code provided", { status: 400 });
	const client = new slack_edge.SlackAPIClient();
	try {
		const secrets = ensureSecrets();
		const response = await client.oauth.v2.access({
			client_id: secrets.clientId,
			client_secret: secrets.clientSecret,
			code
		});
		if (!options?.disableLogging) console.log(`Slack bot authorized for team: ${response.team?.name} (${response.team?.id})`);
		await saveToken(response);
	} catch (error) {
		const message = error instanceof Error ? error.message : "Unknown error";
		return new Response(message, { status: 400 });
	}
	return new Response("The Slack bot has been authorized. It can now be installed in your workspace.", { status: 200 });
};
/**
* Checks if a request is a webhook from Slack.
*
* @param request - The incoming request.
* @returns True if the request is a webhook, false otherwise.
*/
const isWebhook = (request) => {
	return request.headers.get("x-slack-signature") !== null;
};
/**
* handleWebhook handles a Slack webhook request.
*
* @param request - The incoming request.
* @param options - The options for the Slack app.
* @returns A response to Slack.
*/
const handleWebhook = async (request, options) => {
	const app = createSlackApp(options);
	app.event("message", createMessageEventHandler());
	if (!options?.logUnhandledEvents) {
		const silentHandler = async () => {};
		allEventTypes.forEach((event) => {
			app.event(event, silentHandler);
		});
	}
	return app.run(request);
};
/**
* createApp creates a Slack app that is authorized with the
* Slack team bot token. It has no built-in handlers.
*
* Use this to entirely customize the behavior.
*
* @param options - The options for the Slack app.
* @returns The Slack app.
*/
const createSlackApp = (options) => {
	const secrets = ensureSecrets();
	const app = new slack_edge.SlackApp({
		env: { SLACK_SIGNING_SECRET: secrets.signingSecret },
		authorize: async ({ context }) => {
			if (!context.teamId) throw new Error("No team ID provided as part of the Slack webhook.");
			const bot = await getRefreshedToken(context.teamId);
			if (!bot) {
				if (!options?.disableWarnOnMissingToken) console.warn(`Missing bot token for team "${context.teamId}". Install the app from https://api.slack.com/apps in the "Manage Distribution" section.`);
				throw new Error(`Missing bot token for team ${context.teamId}`);
			}
			return {
				botId: bot.botId,
				botUserId: bot.botUserId,
				botToken: bot.accessToken,
				botScopes: bot.scopes
			};
		}
	}).afterAuthorize(async (req) => {
		if (process.env.SLACK_API_BASE_URL) req.context.client = new slack_edge.SlackAPIClient(req.context.botToken, { baseUrl: process.env.SLACK_API_BASE_URL });
	});
	return app;
};
const createMessageEventHandler = (options) => {
	return async (event) => {
		const { payload, context } = event;
		if (payload.subtype !== void 0) return;
		if (!context.teamId) return;
		const parts = [
			"slack",
			context.teamId,
			payload.channel,
			"thread"
		];
		if (payload.thread_ts) parts.push(payload.thread_ts);
		else if (payload.ts) parts.push(payload.ts);
		let message;
		if (options?.createMessage) message = await options.createMessage(event);
		else {
			const userinfo = await context.client.users.info({ user: payload.user }).then((user) => {
				return {
					real_name: user.user?.profile?.real_name ?? "N/A",
					display_name: user.user?.profile?.display_name ?? "N/A"
				};
			}).catch(() => ({
				real_name: "N/A",
				display_name: "N/A"
			}));
			let createdAt = /* @__PURE__ */ new Date();
			try {
				createdAt = /* @__PURE__ */ new Date(parseFloat(payload.ts) * 1e3);
			} catch (err) {}
			message = {
				role: "user",
				parts: [{
					type: "text",
					text: `From Slack User: <@${payload.user}>
Message Timestamp Raw: ${payload.ts} (use for reactions)
Message Timestamp Formatted: ${createdAt.toLocaleString()}
User Real Name: ${userinfo.real_name}
User Display Name: ${userinfo.display_name}

The user is chatting in Slack. You *must* respond with a "slackbot_send_message" tool.`
				}, {
					type: "text",
					text: payload.text
				}]
			};
		}
		const metadata = {
			ts: payload.ts,
			threadTs: payload.thread_ts,
			channel: payload.channel,
			teamId: context.teamId
		};
		const chatID = parts.join("-");
		const send = async (behavior) => {
			await blink.default.chat.message(chatID, {
				...message,
				metadata: {
					...message.metadata ?? {},
					...metadata
				}
			}, { behavior });
		};
		const mentioned = payload.text.includes(`<@${context.botUserId}>`);
		if (!options?.respondToAll && !mentioned) {
			await send("append");
			return;
		}
		await blink.default.chat.upsert(chatID);
		await send("enqueue");
		await context.client.assistant.threads.setStatus({
			channel_id: payload.channel,
			thread_ts: payload.thread_ts || payload.ts,
			status: "is typing..."
		});
	};
};
const allEventTypes = [
	"app_requested",
	"app_installed",
	"app_uninstalled_team",
	"app_deleted",
	"app_home_opened",
	"app_mention",
	"app_uninstalled",
	"assistant_thread_started",
	"assistant_thread_context_changed",
	"channel_archive",
	"channel_created",
	"channel_deleted",
	"channel_history_changed",
	"channel_id_changed",
	"channel_left",
	"channel_rename",
	"channel_shared",
	"channel_unarchive",
	"channel_unshared",
	"dnd_updated",
	"dnd_updated_user",
	"email_domain_changed",
	"emoji_changed",
	"file_change",
	"file_created",
	"file_deleted",
	"file_public",
	"file_shared",
	"file_unshared",
	"function_executed",
	"grid_migration_finished",
	"grid_migration_started",
	"group_archive",
	"group_close",
	"group_deleted",
	"group_history_changed",
	"group_left",
	"group_open",
	"group_rename",
	"group_unarchive",
	"im_close",
	"im_created",
	"im_history_changed",
	"im_open",
	"invite_requested",
	"link_shared",
	"member_joined_channel",
	"member_left_channel",
	"message",
	"message_metadata_deleted",
	"message_metadata_posted",
	"message_metadata_updated",
	"pin_added",
	"pin_removed",
	"reaction_added",
	"reaction_removed",
	"shared_channel_invite_received",
	"shared_channel_invite_accepted",
	"shared_channel_invite_approved",
	"shared_channel_invite_declined",
	"shared_channel_invite_requested",
	"star_added",
	"star_removed",
	"subteam_created",
	"subteam_members_changed",
	"subteam_self_added",
	"subteam_self_removed",
	"subteam_updated",
	"team_access_granted",
	"team_access_revoked",
	"team_domain_change",
	"team_join",
	"team_rename",
	"tokens_revoked",
	"user_change",
	"user_huddle_changed",
	"user_profile_changed",
	"user_status_changed",
	"workflow_deleted",
	"workflow_published",
	"workflow_unpublished",
	"workflow_step_deleted",
	"workflow_step_execute"
];

//#endregion
Object.defineProperty(exports, '__toESM', {
  enumerable: true,
  get: function () {
    return __toESM;
  }
});
Object.defineProperty(exports, 'createMessageEventHandler', {
  enumerable: true,
  get: function () {
    return createMessageEventHandler;
  }
});
Object.defineProperty(exports, 'createSlackApp', {
  enumerable: true,
  get: function () {
    return createSlackApp;
  }
});
Object.defineProperty(exports, 'formatSlackMessage', {
  enumerable: true,
  get: function () {
    return formatSlackMessage;
  }
});
Object.defineProperty(exports, 'getRefreshedToken', {
  enumerable: true,
  get: function () {
    return getRefreshedToken;
  }
});
Object.defineProperty(exports, 'handleOAuthRequest', {
  enumerable: true,
  get: function () {
    return handleOAuthRequest;
  }
});
Object.defineProperty(exports, 'handleWebhook', {
  enumerable: true,
  get: function () {
    return handleWebhook;
  }
});
Object.defineProperty(exports, 'isOAuthRequest', {
  enumerable: true,
  get: function () {
    return isOAuthRequest;
  }
});
Object.defineProperty(exports, 'isWebhook', {
  enumerable: true,
  get: function () {
    return isWebhook;
  }
});