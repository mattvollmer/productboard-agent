"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Assistant = void 0;
const context_1 = require("../context/context");
class Assistant {
    constructor(options = {}) {
        this.threadContextStore = options.threadContextStore;
        this.threadStartedHandler = async (req) => {
            try {
                if ((0, context_1.isAssitantThreadEvent)(req.body)) {
                    const request = req;
                    if (options.threadStarted) {
                        await options.threadStarted(request);
                    }
                    else {
                        const { say, setSuggestedPrompts } = request.context;
                        await say({ text: ":wave: Hi, how can I help you today?" });
                        await setSuggestedPrompts({ title: "New chat", prompts: ["What does SLACK stand for?"] });
                    }
                }
            }
            catch (e) {
                console.error(`Failed to execute threadStartedHandler listener: ${e.stack}`);
            }
        };
        this.threadContextChangedHandler = async (req) => {
            try {
                if ((0, context_1.isAssitantThreadEvent)(req.body)) {
                    const request = req;
                    if (options.threadContextChanged) {
                        await options.threadContextChanged(request);
                    }
                    else {
                        // the defualt implementation
                        const { context } = request;
                        await context.saveThreadContextStore({ ...request.payload.assistant_thread.context });
                    }
                }
            }
            catch (e) {
                console.error(`Failed to execute threadContextChangedHandler listener: ${e.stack}`);
            }
        };
        this.userMessageHandler = async (req) => {
            try {
                if (req.payload.subtype === undefined || req.payload.subtype === "file_share") {
                    if (options.userMessage) {
                        await options.userMessage(req);
                    }
                    else {
                        // noop; just ack the request
                    }
                }
            }
            catch (e) {
                console.error(`Failed to execute userMessageHandler listener: ${e.stack}`);
            }
        };
        this.botMessageHandler = async (req) => {
            try {
                if (req.payload.subtype === undefined && req.payload.user === req.context.botUserId) {
                    if (options.botMessage) {
                        await options.botMessage(req);
                    }
                    else {
                        // noop; just ack the request
                    }
                }
            }
            catch (e) {
                console.error(`Failed to execute botMessageHandler listener: ${e.stack}`);
            }
        };
    }
    threadStarted(handler) {
        this.threadStartedHandler = async (req) => {
            try {
                if ((0, context_1.isAssitantThreadEvent)(req.body)) {
                    await handler(req);
                }
            }
            catch (e) {
                console.error(`Failed to execute threadStartedHandler listener: ${e.stack}`);
            }
        };
    }
    threadContextChanged(handler) {
        this.threadContextChangedHandler = async (req) => {
            try {
                if ((0, context_1.isAssitantThreadEvent)(req.body)) {
                    await handler(req);
                }
            }
            catch (e) {
                console.error(`Failed to execute threadContextChangedHandler listener: ${e.stack}`);
            }
        };
    }
    userMessage(handler) {
        this.userMessageHandler = async (req) => {
            try {
                if (req.payload.subtype === undefined || req.payload.subtype === "file_share") {
                    await handler(req);
                }
            }
            catch (e) {
                console.error(`Failed to execute userMessageHandler listener: ${e.stack}`);
            }
        };
    }
    botMessage(handler) {
        this.botMessageHandler = async (req) => {
            try {
                if (req.payload.subtype === undefined && req.payload.user === req.context.botUserId) {
                    await handler(req);
                }
            }
            catch (e) {
                console.error(`Failed to execute botMessageHandler listener: ${e.stack}`);
            }
        };
    }
}
exports.Assistant = Assistant;
//# sourceMappingURL=assistant.js.map