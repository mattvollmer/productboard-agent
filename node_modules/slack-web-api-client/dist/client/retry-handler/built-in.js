"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerErrorRetryHandler = exports.ConnectionErrorRetryHandler = exports.RatelimitRetryHandler = exports.DefaultFixedIntervalRetryHandlerOptions = exports.DefaultBasicRetryHandlerOptions = void 0;
const errors_1 = require("../../errors");
exports.DefaultBasicRetryHandlerOptions = {
    maxAttempts: 1,
};
exports.DefaultFixedIntervalRetryHandlerOptions = {
    maxAttempts: 1,
    intervalSeconds: 0.3,
};
class RatelimitRetryHandler {
    #maxAttempts;
    constructor(options = exports.DefaultBasicRetryHandlerOptions) {
        this.#maxAttempts = options.maxAttempts;
    }
    async shouldRetry({ state, response }) {
        if (state.currentAttempt >= this.#maxAttempts || !response) {
            return false;
        }
        if (response.status !== 429) {
            return false;
        }
        const retryAfter = response.headers.get("retry-after") || response.headers.get("Retry-After");
        if (!retryAfter || Number.isNaN(retryAfter)) {
            // This could be a Slack server-side issue
            // because the retry-after header is missing while the status is 429
            return false;
        }
        const sleepSeconds = Number.parseFloat(retryAfter);
        await sleep(sleepSeconds);
        return true;
    }
}
exports.RatelimitRetryHandler = RatelimitRetryHandler;
class ConnectionErrorRetryHandler {
    #maxAttempts;
    #intervalSeconds;
    constructor(options = exports.DefaultFixedIntervalRetryHandlerOptions) {
        this.#maxAttempts = options.maxAttempts;
        this.#intervalSeconds = options.intervalSeconds;
    }
    async shouldRetry({ state, error }) {
        if (state.currentAttempt >= this.#maxAttempts || !error) {
            return false;
        }
        if (error instanceof errors_1.SlackAPIConnectionError) {
            await sleep(this.#intervalSeconds);
            return true;
        }
        return false;
    }
}
exports.ConnectionErrorRetryHandler = ConnectionErrorRetryHandler;
class ServerErrorRetryHandler {
    #maxAttempts;
    #intervalSeconds;
    constructor(options = exports.DefaultFixedIntervalRetryHandlerOptions) {
        this.#maxAttempts = options.maxAttempts;
        this.#intervalSeconds = options.intervalSeconds;
    }
    async shouldRetry({ state, response }) {
        if (state.currentAttempt >= this.#maxAttempts || !response) {
            return false;
        }
        if (response.status >= 500) {
            await sleep(this.#intervalSeconds);
            return true;
        }
        return false;
    }
}
exports.ServerErrorRetryHandler = ServerErrorRetryHandler;
const sleep = (seconds) => {
    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
};
//# sourceMappingURL=built-in.js.map