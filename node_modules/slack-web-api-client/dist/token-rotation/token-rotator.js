"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenRotator = void 0;
const errors_1 = require("../errors");
const api_client_1 = require("../client/api-client");
class TokenRotator {
    #clientId;
    #clientSecret;
    #client;
    constructor(options) {
        this.#clientId = options.clientId;
        this.#clientSecret = options.clientSecret;
        this.#client = new api_client_1.SlackAPIClient(undefined, options);
    }
    async performRotation(targets) {
        const refreshResults = {};
        const randomSeconds = Math.round(crypto.getRandomValues(new Uint16Array(1))[0] / 100);
        const expireAt = new Date().getTime() / 1000 + randomSeconds;
        if (targets.bot && targets.bot.token_expires_at < expireAt) {
            try {
                const response = await this.#client.oauth.v2.access({
                    client_id: this.#clientId,
                    client_secret: this.#clientSecret,
                    grant_type: "refresh_token",
                    refresh_token: targets.bot.refresh_token,
                });
                if (response && response.access_token && response.refresh_token && response.expires_in) {
                    refreshResults.bot = {
                        access_token: response.access_token,
                        refresh_token: response.refresh_token,
                        token_expires_at: new Date().getTime() / 1000 + response.expires_in,
                    };
                }
            }
            catch (e) {
                throw new errors_1.TokenRotationError(`Failed to refresh a bot token: ${e}`, e);
            }
        }
        if (targets.user && targets.user.token_expires_at < expireAt) {
            try {
                const response = await this.#client.oauth.v2.access({
                    client_id: this.#clientId,
                    client_secret: this.#clientSecret,
                    grant_type: "refresh_token",
                    refresh_token: targets.user.refresh_token,
                });
                if (response && response.access_token && response.refresh_token && response.expires_in) {
                    refreshResults.user = {
                        access_token: response.access_token,
                        refresh_token: response.refresh_token,
                        token_expires_at: new Date().getTime() / 1000 + response.expires_in,
                    };
                }
            }
            catch (e) {
                throw new errors_1.TokenRotationError(`Failed to refresh a user token: ${e}`, e);
            }
        }
        return refreshResults;
    }
}
exports.TokenRotator = TokenRotator;
//# sourceMappingURL=token-rotator.js.map